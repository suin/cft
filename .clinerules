# cft プロジェクトルール

## コーディングパターン

### 1. ファイル命名規則
- ソースファイル: キャメルケース（例: markdownParser.ts）
- テストファイル: `.test.ts` サフィックス（例: markdownParser.test.ts）
- 型定義ファイル: `.types.ts` サフィックス（例: parser.types.ts）

### 2. コードスタイル
- インデント: 2スペース
- 文字列: シングルクォート
- セミコロン: 必須
- 型定義: 明示的な型付け

### 3. コメント規則
- JSDoc形式を使用
- 英語で記述
- 複雑なロジックには説明を追加

## プロジェクト構造

### 1. ディレクトリ構成
```
src/
├── index.ts         # エントリーポイント
├── converter.ts     # 変換ロジック
├── parser.ts        # Markdownパース
└── utils.ts         # ユーティリティ関数
```

### 2. モジュール依存関係
- 循環依存を避ける
- 依存関係は上位から下位へ
- ユーティリティは最下層に配置

## 開発プラクティス

### 1. バージョン管理
- コミットメッセージは英語
- 機能単位でコミット
- 署名付きコミット（-s オプション使用）

### 2. テスト
- ユニットテストは必須
- テストカバレッジ80%以上
- エッジケースのテストを含める

### 3. エラーハンドリング
- エラーメッセージは英語
- スタックトレースを保持
- 適切なエラー型を使用

## パフォーマンス考慮事項

### 1. メモリ使用
- ストリーム処理を優先
- 大きな文字列の連結を避ける
- メモリリークに注意

### 2. 処理速度
- 非同期処理を活用
- 重い処理は分割
- キャッシュを適切に使用

## セキュリティ規則

### 1. ファイル操作
- パスの検証必須
- 書き込み権限の確認
- ユーザー入力のサニタイズ

### 2. URL処理
- URLの妥当性チェック
- プロトコルの制限（http/https）
- エスケープ処理の実施

## 品質管理

### 1. コードレビュー
- PRは小規模に保つ
- 自動テストの通過必須
- コードスタイルの遵守

### 2. ドキュメント
- README.mdの更新
- 変更履歴の記録
- APIドキュメントの維持

## 重要な実装パターン

### 1. 注釈ID生成
```typescript
// ドメインベースの注釈ID生成
function generateFootnoteId(domain: string, counter: number): string {
  return `[^${domain}-${counter}]`;
}
```

### 2. URL解析
```typescript
// URLの妥当性チェック
function isValidUrl(url: string): boolean {
  return /^https?:\/\//.test(url);
}
```

### 3. 注釈セクション
```markdown
<!-- footernotes:begin -->
[^domain-n]: [タイトル](URL)
<!-- footernotes:end -->
```

## 学習した教訓
1. 正規表現は慎重に最適化
2. ファイル操作は必ずエラーハンドリング
3. メモリ使用量は常に監視
4. ユーザー入力は必ず検証

## 将来の改善点
1. プラグインシステムの設計
2. パフォーマンス最適化
3. エラーメッセージの改善
4. テスト自動化の強化
